# @summary This module manages prometheus cgroup_exporter (https://github.com/treydock/cgroup_exporter)
# @param arch
#  Architecture (x86_64)
# @param bin_dir
#  Directory where binaries are located
# @param download_extension
#  Extension for the release binary archive
# @param download_url
#  Complete URL corresponding to the where the release binary archive can be downloaded
# @param download_url_base
#  Base URL for the binary archive
# @param extra_groups
#  Extra groups to add the binary user to
# @param extra_options
#  Extra options added to the startup command
# @param group
#  Group under which the binary is running
# @param init_style
#  Service startup scripts style (e.g. rc, upstart or systemd)
# @param install_method
#  Installation method: url or package (only url is supported currently)
# @param manage_group
#  Whether to create a group for or rely on external code for that
# @param manage_service
#  Should puppet manage the service? (default true)
# @param manage_user
#  Whether to create user or rely on external code for that
# @param modules
#  Structured, array of blackbox module definitions for different probe types
# @param export_scrape_job
#  Whether to export a scrape job for this service
# @param scrape_host
#  Hostname or IP address to scrape
# @param scrape_port
#  Host port to scrape
# @param scrape_job_name
#  Name of the scrape job to export, if export_scrape_job is true
# @param scrape_job_labels
#  Labels to add to the scrape job, if export_scrape_job is true
# @param os
#  Operating system (linux is the only one supported)
# @param package_ensure
#  If package, then use this for package ensure default 'latest'
# @param package_name
#  The binary package name - not available yet
# @param purge_config_dir
#  Purge config files no longer generated by Puppet
# @param restart_on_change
#  Should puppet restart the service on configuration change? (default true)
# @param service_enable
#  Whether to enable the service from puppet (default true)
# @param service_ensure
#  State ensured for the service (default 'running')
# @param service_name
#  Name of the node exporter service (default 'cgroup_exporter')
# @param user
#  User which runs the service
# @param version
#  The binary release version
# @param proxy_server
#  Optional proxy server, with port number if needed. ie: https://example.com:8080
# @param proxy_type
#  Optional proxy server type (none|http|https|ftp)
# @param cgroup_paths
#  cgroup paths (slurm|user.slice)
# @param unprivileged
#  If true, run the exporter as an unprivileged user and add sudoers entrie to manage the binary exporter
# @param archive_bin_path
#  Path to the binary in the downloaded archive.
# @param env_file_path
#  The path to the file with the environmetn variable that is read from the init script/systemd unit
class prometheus::cgroup_exporter (
  String[1]                                      $package_name       = 'cgroup_exporter',
  String                                         $download_extension = 'tar.gz',
  # renovate: depName=treydock/cgroup_exporter
  String[1]                                      $version            = '1.0.1',
  String[1]                                      $package_ensure     = 'latest',
  String[1]                                      $user               = 'cgroup-exporter',
  String[1]                                      $group              = 'cgroup-exporter',
  Prometheus::Uri                                $download_url_base  = 'https://github.com/treydock/cgroup_exporter/releases',
  Array[String]                                  $extra_groups       = [],
  Prometheus::Initstyle                          $init_style         = $prometheus::init_style,
  Boolean                                        $purge_config_dir   = true,
  String[1]                                      $arch               = $prometheus::real_arch,
  Stdlib::Absolutepath                           $bin_dir            = $prometheus::bin_dir,
  Boolean                                        $restart_on_change  = true,
  Boolean                                        $service_enable     = true,
  Stdlib::Ensure::Service                        $service_ensure     = 'running',
  String[1]                                      $service_name       = 'cgroup_exporter',
  Prometheus::Install                            $install_method     = $prometheus::install_method,
  Boolean                                        $manage_group       = true,
  Boolean                                        $manage_service     = true,
  Boolean                                        $manage_user        = true,
  String[1]                                      $os                 = downcase(fact('kernel')),
  Stdlib::Absolutepath                           $archive_bin_path   = "/opt/${package_name}-${version}.${os}-${arch}/${package_name}",
  Optional[String[1]]                            $extra_options      = undef,
  Optional[Prometheus::Uri]                      $download_url       = undef,
  Optional[Stdlib::Host]                         $scrape_host        = undef,
  Stdlib::Absolutepath                           $env_file_path      = $prometheus::env_file_path,
  Boolean                                        $export_scrape_job  = false,
  Stdlib::Port                                   $scrape_port        = 9306,
  String[1]                                      $scrape_job_name    = 'cgroup',
  Optional[Hash]                                 $scrape_job_labels  = undef,
  Hash                                           $modules            = {},
  Optional[String[1]]                            $proxy_server       = undef,
  Boolean                                        $unprivileged       = false,
  Optional[Enum['none', 'http', 'https', 'ftp']] $proxy_type         = undef,
  Enum['slurm', 'user.slice']                    $cgroup_paths       = 'slurm',
) inherits prometheus {
  $real_download_url = pick(
    $download_url,
    "${download_url_base}/download/v${version}/${package_name}-${version}.${os}-${arch}.${download_extension}"
  )

  $notify_service = $restart_on_change ? {
    true    => Service[$service_name],
    default => undef,
  }

  $paths_option = "--config.paths=/${cgroup_paths}"

  $listen_address = $scrape_port ? {
    9306    => undef,
    default => "--web.listen-address=':${scrape_port}'",
  }

  case fact('os.name') {
    'Debian':  { $unprivileged_os = versioncmp ("${fact('os.release.full')}", '12') == -1 }
    'Ubuntu':  { $unprivileged_os = versioncmp ("${fact('os.release.full')}", '22.04') == -1 }
    default:  { $unprivileged_os = false }
  }

  $bin_name = $package_name

  $options = [
    $extra_options,
    $listen_address,
    $paths_option,
  ].filter |$x| { !$x.empty }.join(' ')

  if $unprivileged or $unprivileged_os {
    # workaround from the ipmi_exporter class
    sudo::conf { $service_name:
      ensure         => 'present',
      content        => join([
          "${user} ALL = NOPASSWD: ${archive_bin_path}",
      ], "\n"),
      sudo_file_name => $service_name,
    }

    file { "${bin_dir}/${bin_name}":
      owner   => $user,
      group   => $group,
      mode    => '0750',
      content => join([
          '#!/bin/bash',
          "sudo ${archive_bin_path} \"$@\"",
      ], "\n"),
    }

    # necessary to ensure that all processes are killed properly with Killmode=mixed
    # if not we encounter those error "cgroup_exporter.service: Unit process XXXXX (sudo) remains running after unit stopped."
    include 'systemd'
    systemd::manage_unit { "${service_name}.service":
      unit_entry    => {
        'Description' => "Prometheus ${package_name}",
        'Wants'       => 'network-online.target',
        'After'       => 'network-online.target',
      },
      service_entry => {
        'User'            => $user,
        'Group'           => $group,
        'EnvironmentFile' => "-${env_file_path}/${package_name}",
        'ExecStart'       => sprintf('%s/%s %s', $bin_dir, $bin_name, $options),
        'ExecReload'      => '/bin/kill -HUP $MAINPID',
        'KillMode'        => 'mixed',
        'Restart'         => 'always',
      },
      install_entry => {
        'WantedBy' => 'multi-user.target',
      },
      notify        => $notify_service,
    }
    $init_style_real = 'none'
  } else {
    exec { 'setcap cgroup_exporter':
      command => "/usr/sbin/setcap cap_sys_ptrace=eip ${archive_bin_path}",
      unless  => "/usr/sbin/getcap ${archive_bin_path} | grep -q cap_sys_ptrace=eip",
      require => Prometheus::Daemon[$service_name],
    }
    $init_style_real = $init_style
  }

  prometheus::daemon { $service_name:
    install_method     => $install_method,
    version            => $version,
    download_extension => $download_extension,
    os                 => $os,
    arch               => $arch,
    real_download_url  => $real_download_url,
    bin_dir            => $bin_dir,
    notify_service     => $notify_service,
    package_name       => $package_name,
    package_ensure     => $package_ensure,
    manage_user        => $manage_user,
    user               => $user,
    extra_groups       => $extra_groups,
    group              => $group,
    manage_group       => $manage_group,
    purge              => $purge_config_dir,
    options            => $options,
    init_style         => $init_style_real,
    service_ensure     => $service_ensure,
    service_enable     => $service_enable,
    manage_service     => $manage_service,
    export_scrape_job  => $export_scrape_job,
    scrape_host        => $scrape_host,
    scrape_port        => $scrape_port,
    scrape_job_name    => $scrape_job_name,
    scrape_job_labels  => $scrape_job_labels,
    bin_name           => $bin_name,
    proxy_server       => $proxy_server,
    proxy_type         => $proxy_type,
    archive_bin_path   => $archive_bin_path,
    manage_bin_link    => !($unprivileged or $unprivileged_os),
  }
}
